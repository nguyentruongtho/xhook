{"version":3,"file":"xhook.min.js","sources":["../src/misc/array.js","../src/misc/window.js","../src/misc/events.js","../src/misc/event-emitter.js","../src/misc/headers.js","../src/misc/hooks.js","../src/patch/xmlhttprequest.js","../src/patch/fetch.js","../src/main.js"],"sourcesContent":["//if required, add 'indexOf' method to Array\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(item) {\n    for (let i = 0; i < this.length; i++) {\n      const x = this[i];\n      if (x === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\nconst slice = (o, n) => Array.prototype.slice.call(o, n);\n\nexport { slice };\n","let result = null;\n\n//find global object\nif (\n  typeof WorkerGlobalScope !== \"undefined\" &&\n  self instanceof WorkerGlobalScope\n) {\n  result = self;\n} else if (typeof global !== \"undefined\") {\n  result = global;\n} else if (window) {\n  result = window;\n}\n\n//find IE version\nconst useragent =\n  typeof navigator !== \"undefined\" && navigator[\"useragent\"]\n    ? navigator.userAgent\n    : \"\";\n\nexport let msie = null;\nif (\n  /msie (\\d+)/.test(useragent.toLowerCase()) ||\n  /trident\\/.*; rv:(\\d+)/.test(useragent.toLowerCase())\n) {\n  msie = parseInt(RegExp.$1, 10);\n}\n\nexport const windowRef = result;\nexport const documentRef = result.document;\n","import { documentRef } from \"./window\";\n\nexport const UPLOAD_EVENTS = [\"load\", \"loadend\", \"loadstart\"];\nexport const COMMON_EVENTS = [\"progress\", \"abort\", \"error\", \"timeout\"];\n\nconst depricatedProp = p =>\n  [\"returnValue\", \"totalSize\", \"position\"].includes(p);\n\nexport const mergeObjects = function(src, dst) {\n  for (let k in src) {\n    if (depricatedProp(k)) {\n      continue;\n    }\n    const v = src[k];\n    try {\n      dst[k] = v;\n    } catch (error) {}\n  }\n  return dst;\n};\n\n//proxy events from one emitter to another\nexport const proxyEvents = function(events, src, dst) {\n  const p = event =>\n    function(e) {\n      const clone = {};\n      //copies event, with dst emitter inplace of src\n      for (let k in e) {\n        if (depricatedProp(k)) {\n          continue;\n        }\n        const val = e[k];\n        clone[k] = val === src ? dst : val;\n      }\n      //emits out the dst\n      return dst.dispatchEvent(event, clone);\n    };\n  //dont proxy manual events\n  for (let event of Array.from(events)) {\n    if (dst._has(event)) {\n      src[`on${event}`] = p(event);\n    }\n  }\n};\n\n//create fake event\nexport const fakeEvent = function(type) {\n  if (documentRef && documentRef.createEventObject != null) {\n    const msieEventObject = documentRef.createEventObject();\n    msieEventObject.type = type;\n    return msieEventObject;\n  }\n  // on some platforms like android 4.1.2 and safari on windows, it appears\n  // that new Event is not allowed\n  try {\n    return new Event(type);\n  } catch (error) {\n    return { type };\n  }\n};\n","import { slice } from \"./array\";\nimport { mergeObjects, fakeEvent } from \"./events\";\n\n//tiny event emitter\nexport const EventEmitter = function(nodeStyle) {\n  //private\n  let events = {};\n  const listeners = event => events[event] || [];\n  //public\n  const emitter = {};\n  emitter.addEventListener = function(event, callback, i) {\n    events[event] = listeners(event);\n    if (events[event].indexOf(callback) >= 0) {\n      return;\n    }\n    i = i === undefined ? events[event].length : i;\n    events[event].splice(i, 0, callback);\n  };\n  emitter.removeEventListener = function(event, callback) {\n    //remove all\n    if (event === undefined) {\n      events = {};\n      return;\n    }\n    //remove all of type event\n    if (callback === undefined) {\n      events[event] = [];\n    }\n    //remove particular handler\n    const i = listeners(event).indexOf(callback);\n    if (i === -1) {\n      return;\n    }\n    listeners(event).splice(i, 1);\n  };\n  emitter.dispatchEvent = function() {\n    const args = slice(arguments);\n    const event = args.shift();\n    if (!nodeStyle) {\n      args[0] = mergeObjects(args[0], fakeEvent(event));\n    }\n    const legacylistener = emitter[`on${event}`];\n    if (legacylistener) {\n      legacylistener.apply(emitter, args);\n    }\n    const iterable = listeners(event).concat(listeners(\"*\"));\n    for (let i = 0; i < iterable.length; i++) {\n      const listener = iterable[i];\n      listener.apply(emitter, args);\n    }\n  };\n  emitter._has = event => !!(events[event] || emitter[`on${event}`]);\n  //add extra aliases\n  if (nodeStyle) {\n    emitter.listeners = event => slice(listeners(event));\n    emitter.on = emitter.addEventListener;\n    emitter.off = emitter.removeEventListener;\n    emitter.fire = emitter.dispatchEvent;\n    emitter.once = function(e, fn) {\n      var fire = function() {\n        emitter.off(e, fire);\n        return fn.apply(null, arguments);\n      };\n      return emitter.on(e, fire);\n    };\n    emitter.destroy = () => (events = {});\n  }\n\n  return emitter;\n};\n","//helper\nconst convert = function(h, dest) {\n  let name;\n  if (dest == null) {\n    dest = {};\n  }\n  switch (typeof h) {\n    case \"object\":\n      var headers = [];\n      for (let k in h) {\n        const v = h[k];\n        name = k.toLowerCase();\n        headers.push(`${name}:\\t${v}`);\n      }\n      return headers.join(\"\\n\") + \"\\n\";\n    case \"string\":\n      headers = h.split(\"\\n\");\n      for (let header of Array.from(headers)) {\n        if (/([^:]+):\\s*(.+)/.test(header)) {\n          name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;\n          const value = RegExp.$2;\n          if (dest[name] == null) {\n            dest[name] = value;\n          }\n        }\n      }\n      return dest;\n  }\n  return [];\n};\n\nexport default { convert };\n","import { EventEmitter } from \"./event-emitter\";\n\n//global set of hook functions,\n//uses event emitter to store hooks\nconst hooks = EventEmitter(true);\n\nexport default hooks;\n","import { windowRef, msie } from \"../misc/window\";\nimport {\n  proxyEvents,\n  mergeObjects,\n  COMMON_EVENTS,\n  UPLOAD_EVENTS\n} from \"../misc/events\";\nimport { EventEmitter } from \"../misc/event-emitter\";\nimport headers from \"../misc/headers\";\nimport hooks from \"../misc/hooks\";\n\nconst nullify = res => (res === undefined ? null : res);\n\n//browser's XMLHttpRequest\nconst Native = windowRef.XMLHttpRequest;\n\n//xhook's XMLHttpRequest\nconst Xhook = function() {\n  const ABORTED = -1;\n  const xhr = new Native();\n\n  //==========================\n  // Extra state\n  const request = {};\n  let status = null;\n  let hasError = undefined;\n  let transiting = undefined;\n  let response = undefined;\n  var currentState = 0;\n\n  //==========================\n  // Private API\n\n  //read results from real xhr into response\n  const readHead = function() {\n    // Accessing attributes on an aborted xhr object will\n    // throw an 'c00c023f error' in IE9 and lower, don't touch it.\n    response.status = status || xhr.status;\n    if (status !== ABORTED || !(msie < 10)) {\n      response.statusText = xhr.statusText;\n    }\n    if (status !== ABORTED) {\n      const object = headers.convert(xhr.getAllResponseHeaders());\n      for (let key in object) {\n        const val = object[key];\n        if (!response.headers[key]) {\n          const name = key.toLowerCase();\n          response.headers[name] = val;\n        }\n      }\n      return;\n    }\n  };\n\n  const readBody = function() {\n    //https://xhr.spec.whatwg.org/\n    if (!xhr.responseType || xhr.responseType === \"text\") {\n      response.text = xhr.responseText;\n      response.data = xhr.responseText;\n      try {\n        response.xml = xhr.responseXML;\n      } catch (error) {}\n      // unable to set responseXML due to response type, we attempt to assign responseXML\n      // when the type is text even though it's against the spec due to several libraries\n      // and browser vendors who allow this behavior. causing these requests to fail when\n      // xhook is installed on a page.\n    } else if (xhr.responseType === \"document\") {\n      response.xml = xhr.responseXML;\n      response.data = xhr.responseXML;\n    } else {\n      response.data = xhr.response;\n    }\n    //new in some browsers\n    if (\"responseURL\" in xhr) {\n      response.finalUrl = xhr.responseURL;\n    }\n  };\n\n  //write response into facade xhr\n  const writeHead = function() {\n    facade.status = response.status;\n    facade.statusText = response.statusText;\n  };\n\n  const writeBody = function() {\n    if (\"text\" in response) {\n      facade.responseText = response.text;\n    }\n    if (\"xml\" in response) {\n      facade.responseXML = response.xml;\n    }\n    if (\"data\" in response) {\n      facade.response = response.data;\n    }\n    if (\"finalUrl\" in response) {\n      facade.responseURL = response.finalUrl;\n    }\n  };\n\n  const emitFinal = function() {\n    if (!hasError) {\n      facade.dispatchEvent(\"load\", {});\n    }\n    facade.dispatchEvent(\"loadend\", {});\n    if (hasError) {\n      facade.readyState = 0;\n    }\n  };\n\n  //ensure ready state 0 through 4 is handled\n  const emitReadyState = function(n) {\n    while (n > currentState && currentState < 4) {\n      facade.readyState = ++currentState;\n      // make fake events for libraries that actually check the type on\n      // the event object\n      if (currentState === 1) {\n        facade.dispatchEvent(\"loadstart\", {});\n      }\n      if (currentState === 2) {\n        writeHead();\n      }\n      if (currentState === 4) {\n        writeHead();\n        writeBody();\n      }\n      facade.dispatchEvent(\"readystatechange\", {});\n      //delay final events incase of error\n      if (currentState === 4) {\n        if (request.async === false) {\n          emitFinal();\n        } else {\n          setTimeout(emitFinal, 0);\n        }\n      }\n    }\n  };\n\n  //control facade ready state\n  const setReadyState = function(n) {\n    //emit events until readyState reaches 4\n    if (n !== 4) {\n      emitReadyState(n);\n      return;\n    }\n    //before emitting 4, run all 'after' hooks in sequence\n    const afterHooks = hooks.listeners(\"after\");\n    var process = function() {\n      if (afterHooks.length > 0) {\n        //execute each 'before' hook one at a time\n        const hook = afterHooks.shift();\n        if (hook.length === 2) {\n          hook(request, response);\n          process();\n        } else if (hook.length === 3 && request.async) {\n          hook(request, response, process);\n        } else {\n          process();\n        }\n      } else {\n        //response ready for reading\n        emitReadyState(4);\n      }\n      return;\n    };\n    process();\n  };\n\n  //==========================\n  // Facade XHR\n  var facade = EventEmitter();\n  request.xhr = facade;\n\n  // Handle the underlying ready state\n  xhr.onreadystatechange = function(event) {\n    //pull status and headers\n    try {\n      if (xhr.readyState === 2) {\n        readHead();\n      }\n    } catch (error) {}\n    //pull response data\n    if (xhr.readyState === 4) {\n      transiting = false;\n      readHead();\n      readBody();\n    }\n\n    setReadyState(xhr.readyState);\n  };\n\n  //mark this xhr as errored\n  const hasErrorHandler = function() {\n    hasError = true;\n  };\n  facade.addEventListener(\"error\", hasErrorHandler);\n  facade.addEventListener(\"timeout\", hasErrorHandler);\n  facade.addEventListener(\"abort\", hasErrorHandler);\n  // progress means we're current downloading...\n  facade.addEventListener(\"progress\", function(event) {\n    if (currentState < 3) {\n      setReadyState(3);\n    } else if (xhr.readyState <= 3) {\n      //until ready (4), each progress event is followed by readystatechange...\n      facade.dispatchEvent(\"readystatechange\", {}); //TODO fake an XHR event\n    }\n  });\n\n  // initialise 'withCredentials' on facade xhr in browsers with it\n  // or if explicitly told to do so\n  if (\"withCredentials\" in xhr) {\n    facade.withCredentials = false;\n  }\n  facade.status = 0;\n\n  // initialise all possible event handlers\n  for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {\n    facade[`on${event}`] = null;\n  }\n\n  facade.open = function(method, url, async, user, pass) {\n    // Initailize empty XHR facade\n    currentState = 0;\n    hasError = false;\n    transiting = false;\n    //reset request\n    request.headers = {};\n    request.headerNames = {};\n    request.status = 0;\n    request.method = method;\n    request.url = url;\n    request.async = async !== false;\n    request.user = user;\n    request.pass = pass;\n    //reset response\n    response = {};\n    response.headers = {};\n    // openned facade xhr (not real xhr)\n    setReadyState(1);\n  };\n\n  facade.send = function(body) {\n    //read xhr settings before hooking\n    let k, modk;\n    for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n      modk = k === \"type\" ? \"responseType\" : k;\n      if (modk in facade) {\n        request[k] = facade[modk];\n      }\n    }\n\n    request.body = body;\n    const send = function() {\n      //proxy all events from real xhr to facade\n      proxyEvents(COMMON_EVENTS, xhr, facade);\n      //proxy all upload events from the real to the upload facade\n      if (facade.upload) {\n        proxyEvents(\n          COMMON_EVENTS.concat(UPLOAD_EVENTS),\n          xhr.upload,\n          facade.upload\n        );\n      }\n\n      //prepare request all at once\n      transiting = true;\n      //perform open\n      xhr.open(\n        request.method,\n        request.url,\n        request.async,\n        request.user,\n        request.pass\n      );\n\n      //write xhr settings\n      for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n        modk = k === \"type\" ? \"responseType\" : k;\n        if (k in request) {\n          xhr[modk] = request[k];\n        }\n      }\n\n      //insert headers\n      for (let header in request.headers) {\n        const value = request.headers[header];\n        if (header) {\n          xhr.setRequestHeader(header, value);\n        }\n      }\n      //real send!\n      xhr.send(request.body);\n    };\n\n    const beforeHooks = hooks.listeners(\"before\");\n    //process beforeHooks sequentially\n    var process = function() {\n      if (!beforeHooks.length) {\n        return send();\n      }\n      //go to next hook OR optionally provide response\n      const done = function(userResponse) {\n        //break chain - provide dummy response (readyState 4)\n        if (\n          typeof userResponse === \"object\" &&\n          (typeof userResponse.status === \"number\" ||\n            typeof response.status === \"number\")\n        ) {\n          mergeObjects(userResponse, response);\n          if (!(\"data\" in userResponse)) {\n            userResponse.data = userResponse.response || userResponse.text;\n          }\n          setReadyState(4);\n          return;\n        }\n        //continue processing until no beforeHooks left\n        process();\n      };\n      //specifically provide headers (readyState 2)\n      done.head = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(2);\n      };\n      //specifically provide partial text (responseText  readyState 3)\n      done.progress = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(3);\n      };\n\n      const hook = beforeHooks.shift();\n      //async or sync?\n      if (hook.length === 1) {\n        done(hook(request));\n      } else if (hook.length === 2 && request.async) {\n        //async handlers must use an async xhr\n        hook(request, done);\n      } else {\n        //skip async hook on sync requests\n        done();\n      }\n      return;\n    };\n    //kick off\n    process();\n  };\n\n  facade.abort = function() {\n    status = ABORTED;\n    if (transiting) {\n      xhr.abort(); //this will emit an 'abort' for us\n    } else {\n      facade.dispatchEvent(\"abort\", {});\n    }\n  };\n\n  facade.setRequestHeader = function(header, value) {\n    //the first header set is used for all future case-alternatives of 'name'\n    const lName = header != null ? header.toLowerCase() : undefined;\n    const name = (request.headerNames[lName] =\n      request.headerNames[lName] || header);\n    //append header to any previous values\n    if (request.headers[name]) {\n      value = request.headers[name] + \", \" + value;\n    }\n    request.headers[name] = value;\n  };\n  facade.getResponseHeader = header =>\n    nullify(response.headers[header ? header.toLowerCase() : undefined]);\n\n  facade.getAllResponseHeaders = () =>\n    nullify(headers.convert(response.headers));\n\n  //proxy call only when supported\n  if (xhr.overrideMimeType) {\n    facade.overrideMimeType = function() {\n      xhr.overrideMimeType.apply(xhr, arguments);\n    };\n  }\n\n  //create emitter when supported\n  if (xhr.upload) {\n    let up = EventEmitter();\n    facade.upload = up;\n    request.upload = up;\n  }\n\n  facade.UNSENT = 0;\n  facade.OPENED = 1;\n  facade.HEADERS_RECEIVED = 2;\n  facade.LOADING = 3;\n  facade.DONE = 4;\n\n  // fill in default values for an empty XHR object according to the spec\n  facade.response = \"\";\n  facade.responseText = \"\";\n  facade.responseXML = null;\n  facade.readyState = 0;\n  facade.statusText = \"\";\n\n  return facade;\n};\n\nXhook.UNSENT = 0;\nXhook.OPENED = 1;\nXhook.HEADERS_RECEIVED = 2;\nXhook.LOADING = 3;\nXhook.DONE = 4;\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      windowRef.XMLHttpRequest = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      windowRef.XMLHttpRequest = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { windowRef } from \"../misc/window\";\nimport { mergeObjects } from \"../misc/events\";\nimport hooks from \"../misc/hooks\";\n\n//browser's fetch\nconst Native = windowRef.fetch;\n\n//xhook's fetch\nconst Xhook = function(url, options) {\n  if (options == null) {\n    options = { headers: {} };\n  }\n\n  let request = null;\n\n  if (url instanceof Request) {\n    request = url\n  } else {\n    options.url = url;\n  }\n\n  const beforeHooks = hooks.listeners(\"before\");\n  const afterHooks = hooks.listeners(\"after\");\n\n  return new Promise(function(resolve, reject) {\n    let fullfiled = resolve\n    const getRequest = function() {\n      if (options.headers) {\n        options.headers = new Headers(options.headers);\n      }\n\n      if (!request) {\n        request = new Request(options.url, options);\n      }\n\n      return mergeObjects(options, request);\n    };\n\n    var processAfter = function(response) {\n      if (!afterHooks.length) {\n        return fullfiled(response);\n      }\n\n      const hook = afterHooks.shift();\n\n      if (hook.length === 2) {\n        hook(getRequest(), response);\n        return processAfter(response);\n      } else if (hook.length === 3) {\n        return hook(getRequest(), response, processAfter);\n      } else {\n        return processAfter(response);\n      }\n    };\n\n    const done = function(userResponse) {\n      if (userResponse !== undefined) {\n        const response = new Response(\n          userResponse.body || userResponse.text,\n          userResponse\n        );\n        resolve(response);\n        processAfter(response);\n        return;\n      }\n\n      //continue processing until no hooks left\n      processBefore();\n    };\n\n    var processBefore = function() {\n      if (!beforeHooks.length) {\n        send();\n        return;\n      }\n\n      const hook = beforeHooks.shift();\n\n      if (hook.length === 1) {\n        return done(hook(options));\n      } else if (hook.length === 2) {\n        return hook(getRequest(), done);\n      }\n    };\n\n    var send = () =>\n      Native(getRequest())\n        .then(response => processAfter(response))\n        .catch(function(err) {\n          fullfiled = reject\n          processAfter(err);\n          return reject(err);\n        });\n\n    processBefore();\n  });\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      windowRef.fetch = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      windowRef.fetch = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { EventEmitter } from \"./misc/event-emitter\";\nimport headers from \"./misc/headers\";\n\n//patchable types\nimport XMLHttpRequest from \"./patch/xmlhttprequest\";\nimport fetch from \"./patch/fetch\";\n\n//global state\nimport hooks from \"./misc/hooks\";\n//the global hooks event emitter is also the global xhook object\n//(not the best decision in hindsight)\nconst xhook = hooks;\nxhook.EventEmitter = EventEmitter;\n//modify hooks\nxhook.before = function(handler, i) {\n  if (handler.length < 1 || handler.length > 2) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"before\", handler, i);\n};\nxhook.after = function(handler, i) {\n  if (handler.length < 2 || handler.length > 3) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"after\", handler, i);\n};\n\n//globally enable/disable\nxhook.enable = function() {\n  XMLHttpRequest.patch();\n  fetch.patch();\n};\nxhook.disable = function() {\n  XMLHttpRequest.unpatch();\n  fetch.unpatch();\n};\n//expose native objects\nxhook.XMLHttpRequest = XMLHttpRequest.Native;\nxhook.fetch = fetch.Native;\n\n//expose helpers\nxhook.headers = headers.convert;\n\n//enable by default\nxhook.enable();\n\n\nexport default xhook;\n"],"names":["Array","prototype","indexOf","item","i","this","length","slice","o","n","call","result","WorkerGlobalScope","self","global","window","useragent","navigator","userAgent","msie","test","toLowerCase","parseInt","RegExp","$1","windowRef","documentRef","document","UPLOAD_EVENTS","COMMON_EVENTS","depricatedProp","p","includes","mergeObjects","src","dst","k","v","error","proxyEvents","events","event","e","clone","val","dispatchEvent","from","_has","fakeEvent","type","createEventObject","msieEventObject","Event","EventEmitter","nodeStyle","listeners","emitter","callback","undefined","splice","args","arguments","shift","legacylistener","apply","iterable","concat","on","addEventListener","off","removeEventListener","fire","once","fn","destroy","headers","h","dest","name","push","join","split","header","value","$2","hooks","nullify","res","Native","XMLHttpRequest","Xhook","xhr","request","hasError","transiting","response","status","currentState","readHead","statusText","object","getAllResponseHeaders","key","writeHead","facade","emitFinal","readyState","emitReadyState","responseText","text","responseXML","xml","data","responseURL","finalUrl","async","setTimeout","setReadyState","afterHooks","process","hook","onreadystatechange","responseType","readBody","hasErrorHandler","withCredentials","open","method","url","user","pass","headerNames","send","body","modk","beforeHooks","upload","setRequestHeader","done","userResponse","head","progress","abort","lName","getResponseHeader","overrideMimeType","up","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","patch","unpatch","fetch","options","Request","Promise","resolve","reject","fullfiled","getRequest","Headers","processAfter","Response","processBefore","then","catch","err","xhook","before","handler","after","enable","disable"],"mappings":"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"}